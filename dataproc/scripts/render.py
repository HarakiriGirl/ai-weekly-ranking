#!/usr/bin/env python3
"""
é€±æ¬¡ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆã‚¹ã‚¯ãƒªãƒ—ãƒˆ
- weekly/*.parquet ã‹ã‚‰ãƒ©ãƒ³ã‚­ãƒ³ã‚°ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿
- ã‚¸ãƒ£ãƒ³ãƒ«åˆ¥TOP3ã‚’Markdownå½¢å¼ã§å‡ºåŠ›
- NEWåˆ¤å®šãƒ»ã‚¹ã‚³ã‚¢è¡¨ç¤º
- reports/*.md ã¨ã—ã¦ä¿å­˜
"""

import pandas as pd
import yaml
from pathlib import Path
from datetime import datetime
import argparse

def get_current_week():
    """ç¾åœ¨ã®é€±ç•ªå·å–å¾— (ISOé€±ç•ªå·)"""
    now = datetime.now()
    year, week, _ = now.isocalendar()
    return f"{year}-W{week:02d}"

def load_genres():
    """ã‚¸ãƒ£ãƒ³ãƒ«å®šç¾©èª­ã¿è¾¼ã¿"""
    genres_path = Path("dataproc/config/genres.yml")
    
    if not genres_path.exists():
        return ['multi-ai', 'image', 'video', 'music', 'voice', 'research', 'coding', 'agent-workflow']
    
    with open(genres_path, 'r', encoding='utf-8') as f:
        return yaml.safe_load(f) or []

def load_ranking_data(week):
    """ãƒ©ãƒ³ã‚­ãƒ³ã‚°ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿"""
    weekly_dir = Path("dataproc/aggregated")
    ranking_file = weekly_dir / f"{week}.parquet"
    
    if not ranking_file.exists():
        print(f"No ranking data found: {ranking_file}")
        return pd.DataFrame()
    
    print(f"Reading ranking data: {ranking_file}")
    return pd.read_parquet(ranking_file)

def get_genre_display_name(genre):
    """ã‚¸ãƒ£ãƒ³ãƒ«è¡¨ç¤ºåå–å¾—"""
    display_names = {
        'multi-ai': 'ğŸ¤– æ±ç”¨AIãƒ»ãƒãƒ£ãƒƒãƒˆãƒœãƒƒãƒˆ',
        'image': 'ğŸ¨ ç”»åƒç”Ÿæˆãƒ»ç·¨é›†',
        'video': 'ğŸ¬ å‹•ç”»ç”Ÿæˆãƒ»ç·¨é›†', 
        'music': 'ğŸµ éŸ³æ¥½ãƒ»éŸ³å£°ç”Ÿæˆ',
        'voice': 'ğŸ™ï¸ éŸ³å£°èªè­˜ãƒ»åˆæˆ',
        'research': 'ğŸ“š ç ”ç©¶ãƒ»åˆ†æãƒ»è«–æ–‡',
        'coding': 'ğŸ’» ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°æ”¯æ´',
        'agent-workflow': 'ğŸ”„ è‡ªå‹•åŒ–ãƒ»ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ'
    }
    return display_names.get(genre, f'ğŸ“Š {genre.title()}')

def format_score(score):
    """ã‚¹ã‚³ã‚¢è¡¨ç¤ºãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ"""
    if score >= 10:
        return f"{score:.0f}pt"
    else:
        return f"{score:.1f}pt"

def get_week_period(week):
    """é€±ã®æœŸé–“è¡¨ç¤º"""
    year, week_num = week.split('-W')
    year, week_num = int(year), int(week_num)
    
    # ISOé€±ç•ªå·ã‹ã‚‰æ—¥ä»˜è¨ˆç®—
    jan4 = datetime(year, 1, 4)
    week_start = jan4 + pd.Timedelta(weeks=week_num-1) - pd.Timedelta(days=jan4.weekday())
    week_end = week_start + pd.Timedelta(days=6)
    
    return f"{week_start.strftime('%Y/%m/%d')} - {week_end.strftime('%m/%d')}"

def generate_report(week=None):
    """ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆãƒ¡ã‚¤ãƒ³å‡¦ç†"""
    
    if week is None:
        week = get_current_week()
    
    print(f"Generating report for week: {week}")
    
    # ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿
    genres = load_genres()
    rankings_df = load_ranking_data(week)
    
    if rankings_df.empty:
        print("No ranking data available")
        # ç©ºã®ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ
        content = generate_empty_report(week, genres)
    else:
        print(f"Loaded {len(rankings_df)} rankings")
        content = generate_full_report(week, genres, rankings_df)
    
    # ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜
    reports_dir = Path("dataproc/reports")
    reports_dir.mkdir(exist_ok=True)
    
    output_path = reports_dir / f"{week}.md"
    
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(content)
    
    print(f"Report saved: {output_path}")
    return output_path

def generate_empty_report(week, genres):
    """ç©ºã®ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ"""
    week_period = get_week_period(week)
    
    content = f"""# AIãƒ„ãƒ¼ãƒ«é€±æ¬¡ãƒ©ãƒ³ã‚­ãƒ³ã‚° {week}

**é›†è¨ˆæœŸé–“:** {week_period}  
**ãƒ‡ãƒ¼ã‚¿æ›´æ–°:** {datetime.now().strftime('%Y/%m/%d %H:%M')}

---

## ğŸ“Š ä»Šé€±ã®ãƒã‚¤ãƒ©ã‚¤ãƒˆ

ä»Šé€±ã¯ãƒ©ãƒ³ã‚­ãƒ³ã‚°å¯¾è±¡ã¨ãªã‚‹AIãƒ„ãƒ¼ãƒ«ã®è¨€åŠãŒæ¤œå‡ºã•ã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚

---

"""
    
    # å„ã‚¸ãƒ£ãƒ³ãƒ«ã«ç©ºã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³è¿½åŠ 
    for genre in genres:
        display_name = get_genre_display_name(genre)
        content += f"""## {display_name}

ä»Šé€±ã¯ãƒ©ãƒ³ã‚­ãƒ³ã‚°å¯¾è±¡ã®ãƒ„ãƒ¼ãƒ«ãŒæ¤œå‡ºã•ã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚

---

"""
    
    content += f"""## ğŸ“ˆ ãƒ‡ãƒ¼ã‚¿ã«ã¤ã„ã¦

- **å¯¾è±¡ã‚½ãƒ¼ã‚¹:** Reddit AIé–¢é€£ã‚µãƒ–ãƒ¬ãƒ‡ã‚£ãƒƒãƒˆã€YouTubeæŠ€è¡“ãƒãƒ£ãƒ³ãƒãƒ«ã€AIé–¢é€£RSSãƒ•ã‚£ãƒ¼ãƒ‰
- **ã‚¹ã‚³ã‚¢è¨ˆç®—:** è¨€åŠå›æ•° Ã— ã‚½ãƒ¼ã‚¹é‡ã¿ + å‰é€±ã‚¹ã‚³ã‚¢ Ã— 0.5
- **ãƒ©ãƒ³ã‚­ãƒ³ã‚°:** å„ã‚¸ãƒ£ãƒ³ãƒ«TOP3ã‚’è¡¨ç¤º

---

*Generated by AI Weekly Ranking Pipeline v2*
"""
    
    return content

def generate_full_report(week, genres, rankings_df):
    """å®Œå…¨ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ"""
    week_period = get_week_period(week)
    
    # ãƒã‚¤ãƒ©ã‚¤ãƒˆæƒ…å ±åé›†
    total_tools = len(rankings_df['tool'].unique())
    new_tools = rankings_df[rankings_df['is_new'] == True]['tool'].unique()
    top_score = rankings_df['score'].max() if not rankings_df.empty else 0
    
    content = f"""# AIãƒ„ãƒ¼ãƒ«é€±æ¬¡ãƒ©ãƒ³ã‚­ãƒ³ã‚° {week}

**é›†è¨ˆæœŸé–“:** {week_period}  
**ãƒ‡ãƒ¼ã‚¿æ›´æ–°:** {datetime.now().strftime('%Y/%m/%d %H:%M')}

---

## ğŸ“Š ä»Šé€±ã®ãƒã‚¤ãƒ©ã‚¤ãƒˆ

- **ãƒ©ãƒ³ã‚¯ã‚¤ãƒ³:** {total_tools}ãƒ„ãƒ¼ãƒ«
- **æœ€é«˜ã‚¹ã‚³ã‚¢:** {format_score(top_score)}

---

"""
    
    # ã‚¸ãƒ£ãƒ³ãƒ«åˆ¥ãƒ©ãƒ³ã‚­ãƒ³ã‚°
    for genre in genres:
        display_name = get_genre_display_name(genre)
        genre_rankings = rankings_df[rankings_df['genre'] == genre].sort_values('rank')
        
        content += f"## {display_name}\n\n"
        
        if genre_rankings.empty:
            content += "ä»Šé€±ã¯ãƒ©ãƒ³ã‚­ãƒ³ã‚°å¯¾è±¡ã®ãƒ„ãƒ¼ãƒ«ãŒæ¤œå‡ºã•ã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚\n\n"
        else:
            for _, row in genre_rankings.iterrows():
                rank = row['rank']
                tool = row['tool']
                score = row['score']
                
                # ãƒ©ãƒ³ã‚­ãƒ³ã‚°è¡¨ç¤º
                if rank == 1:
                    medal = "ğŸ¥‡"
                elif rank == 2:
                    medal = "ğŸ¥ˆ"
                elif rank == 3:
                    medal = "ğŸ¥‰"
                else:
                    medal = f"{rank}."
                
                content += f"{medal} **{tool}** - {format_score(score)}\n\n"
        
        content += "---\n\n"
    
    content += f"""## ğŸ“ˆ ãƒ‡ãƒ¼ã‚¿ã«ã¤ã„ã¦

- **å¯¾è±¡ã‚½ãƒ¼ã‚¹:** Reddit AIé–¢é€£ã‚µãƒ–ãƒ¬ãƒ‡ã‚£ãƒƒãƒˆã€YouTubeæŠ€è¡“ãƒãƒ£ãƒ³ãƒãƒ«ã€AIé–¢é€£RSSãƒ•ã‚£ãƒ¼ãƒ‰
- **ã‚¹ã‚³ã‚¢è¨ˆç®—:** è¨€åŠå›æ•° Ã— ã‚½ãƒ¼ã‚¹é‡ã¿ + å‰é€±ã‚¹ã‚³ã‚¢ Ã— 0.5
- **ãƒ©ãƒ³ã‚­ãƒ³ã‚°:** å„ã‚¸ãƒ£ãƒ³ãƒ«TOP3ã‚’è¡¨ç¤º

---

*Generated by AI Weekly Ranking Pipeline v2*
"""
    
    return content

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Generate weekly ranking report')
    parser.add_argument('--week', type=str, help='Week in YYYY-WXX format (default: current week)')
    
    args = parser.parse_args()
    generate_report(args.week)